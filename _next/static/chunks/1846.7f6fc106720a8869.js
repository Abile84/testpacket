"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1846],{11846:function(t,r,a){a.d(r,{e:function(){return Erc20SignatureMintable},f:function(){return Erc20}});var e=a(2593),n=a(61744),c=a(68828),i=a(7860),s=a(89208),o=a(89536),p=a(19578),l=a(62245),h=a(38776),m=a(19824),u=a(41518),d=a(58179);let Erc20BatchMintable=class Erc20BatchMintable{featureName=i.cG.name;constructor(t,r){this.erc20=t,this.contractWrapper=r}to=(0,p.c)(async t=>{let r=new c.C(this.contractWrapper),a=await Promise.all(t.map(t=>Promise.all([(0,i.aP)(t.toAddress),this.erc20.normalizeAmount(t.amount)]))),e=a.map(t=>{let[a,e]=t;return r.encode("mintTo",[a,e])});return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e]})})};let Erc20Burnable=class Erc20Burnable{featureName=i.cH.name;constructor(t,r){this.erc20=t,this.contractWrapper=r}tokens=(0,p.c)(async t=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]}));from=(0,p.c)(async(t,r)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:await Promise.all([(0,i.aP)(t),this.erc20.normalizeAmount(r)])}))};let Erc20ClaimableWithConditions=class Erc20ClaimableWithConditions{featureName=i.cI.name;constructor(t,r,a){this.erc20=t,this.contractWrapper=r,this.storage=a;let e=new o.C(this.contractWrapper,i.bk,this.storage);this.conditions=new l.D(this.contractWrapper,e,this.storage)}to=(0,p.c)(async(t,r,a)=>{let e=await this.erc20.normalizeAmount(r);return await this.conditions.getClaimTransaction(t,e,a)})};let Erc20Droppable=class Erc20Droppable{constructor(t,r,a){this.erc20=t,this.contractWrapper=r,this.storage=a,this.claim=new Erc20ClaimableWithConditions(this.erc20,this.contractWrapper,this.storage)}};let Erc20Mintable=class Erc20Mintable{featureName=i.cJ.name;constructor(t,r){this.erc20=t,this.contractWrapper=r,this.batch=this.detectErc20BatchMintable()}to=(0,p.c)(async(t,r)=>await this.getMintTransaction(t,r));async getMintTransaction(t,r){return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:await Promise.all([(0,i.aP)(t),this.erc20.normalizeAmount(r)])})}detectErc20BatchMintable(){if((0,o.d)(this.contractWrapper,"ERC20BatchMintable"))return new Erc20BatchMintable(this.erc20,this.contractWrapper)}};let Erc20SignatureMintable=class Erc20SignatureMintable{featureName=i.cK.name;constructor(t,r){this.contractWrapper=t,this.roles=r}mint=(0,p.c)(async t=>{let r=t.payload,a=t.signature,[n,c]=await Promise.all([this.mapPayloadToContractStruct(r),this.contractWrapper.getCallOverrides()]);return await (0,u.s)(this.contractWrapper,e.O$.from(n.price),r.currencyAddress,c),p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[n,a],overrides:c})});mintBatch=(0,p.c)(async t=>{let r=await Promise.all(t.map(t=>this.mapPayloadToContractStruct(t.payload))),a=t.map((t,a)=>{let n=r[a],c=t.signature,i=t.payload.price;if(e.O$.from(i).gt(0))throw Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:n,signature:c}}),n=new c.C(this.contractWrapper),i=a.map(t=>n.encode("mintWithSignature",[t.message,t.signature]));return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i]})});async verify(t){let r=t.payload,a=t.signature,e=await this.mapPayloadToContractStruct(r),n=await this.contractWrapper.read("verify",[e,a]);return n[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){await this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress());let[r,a,e]=await Promise.all([this.contractWrapper.getChainID(),this.contractWrapper.read("name",[]),Promise.all(t.map(t=>d.S.parseAsync(t)))]),n=this.contractWrapper.getSigner();(0,h.Z)(n,"No signer available");let c=await Promise.all(e.map(t=>d.k.parseAsync(t))),i=await Promise.all(c.map(t=>this.mapPayloadToContractStruct(t))),s=await Promise.all(i.map(t=>this.contractWrapper.signTypedData(n,{name:a,version:"1",chainId:r,verifyingContract:this.contractWrapper.address},{MintRequest:d.M},t)));return e.map((t,r)=>{let a=c[r],e=s[r];return{payload:a,signature:e.toString()}})}async mapPayloadToContractStruct(t){let[r,a]=await Promise.all([(0,m.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),this.contractWrapper.read("decimals",[])]),e=n.parseUnits(t.quantity,a);return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:e,price:r,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}};async function normalizeAmount(t,r){let a=await t.read("decimals",[]);return n.parseUnits(i.cz.parse(r),a)}let Erc20=class Erc20{featureName=i.cL.name;get chainId(){return this._chainId}constructor(t,r,a){this.contractWrapper=t,this.storage=r,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=a}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return await (0,c.f)(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.read("balanceOf",[await (0,i.aP)(t)]))}async totalSupply(){return await this.getValue(await this.contractWrapper.read("totalSupply",[]))}async allowance(t){let[r,a]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,i.aP)(t)]);return await this.allowanceOf(r,a)}async allowanceOf(t,r){let a=await Promise.all([(0,i.aP)(t),(0,i.aP)(r)]);return await this.getValue(await this.contractWrapper.read("allowance",a))}transfer=(0,p.c)(async(t,r)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:await Promise.all([(0,i.aP)(t),this.normalizeAmount(r)])}));transferFrom=(0,p.c)(async(t,r,a)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:await Promise.all([(0,i.aP)(t),(0,i.aP)(r),this.normalizeAmount(a)])}));setAllowance=(0,p.c)(async(t,r)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:await Promise.all([(0,i.aP)(t),this.normalizeAmount(r)])}));transferBatch=(0,p.c)(async t=>{let r=new c.C(this.contractWrapper),a=(await Promise.all(t.map(t=>Promise.all([this.normalizeAmount(t.amount),(0,i.aP)(t.toAddress)])))).map(t=>{let[a,e]=t;return r.encode("transfer",[e,a])});return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a]})});mint=(0,p.c)(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t));mintTo=(0,p.c)(async(t,r)=>(0,s.a)(this.mintable,i.cJ).to.prepare(t,r));async getMintTransaction(t,r){return(0,s.a)(this.mintable,i.cJ).getMintTransaction(t,r)}mintBatchTo=(0,p.c)(async t=>(0,s.a)(this.mintable?.batch,i.cG).to.prepare(t));burn=(0,p.c)(async t=>(0,s.a)(this.burnable,i.cH).tokens.prepare(t));burnFrom=(0,p.c)(async(t,r)=>(0,s.a)(this.burnable,i.cH).from.prepare(t,r));claim=(0,p.c)(async(t,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,r));claimTo=(0,p.c)(async(t,r,a)=>(0,s.a)(this.droppable?.claim,i.cI).to.prepare(t,r,a));get claimConditions(){return(0,s.a)(this.droppable?.claim,i.cI).conditions}get signature(){return(0,s.a)(this.signatureMintable,i.cK)}async normalizeAmount(t){return normalizeAmount(this.contractWrapper,t)}async getValue(t){return await (0,c.a)(this.contractWrapper.getProvider(),this.getAddress(),e.O$.from(t))}detectErc20Mintable(){if((0,o.d)(this.contractWrapper,"ERC20"))return new Erc20Mintable(this,this.contractWrapper)}detectErc20Burnable(){if((0,o.d)(this.contractWrapper,"ERC20Burnable"))return new Erc20Burnable(this,this.contractWrapper)}detectErc20Droppable(){if((0,o.d)(this.contractWrapper,"ERC20ClaimConditionsV1")||(0,o.d)(this.contractWrapper,"ERC20ClaimConditionsV2")||(0,o.d)(this.contractWrapper,"ERC20ClaimPhasesV1")||(0,o.d)(this.contractWrapper,"ERC20ClaimPhasesV2"))return new Erc20Droppable(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if((0,o.d)(this.contractWrapper,"ERC20SignatureMintable"))return new Erc20SignatureMintable(this.contractWrapper)}}}}]);